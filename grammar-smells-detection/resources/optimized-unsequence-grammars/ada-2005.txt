comment ::= "-" "-" non_end_of_line_character* ;
non_end_of_line_character ::= "character" ;
pragma ::= "pragma" identifier ("(" pragma_argument_association ("," pragma_argument_association)* ")")? ";" ;
pragma_argument_association ::= ((pragma_argument_identifier "=>")? name) | ((pragma_argument_identifier "=>")? expression) ;
pragma_argument_identifier ::= identifier ;
compilation ::= compilation_unit* ;
compilation_unit ::= (context_clause library_item) | (context_clause subunit) ;
library_item ::= ("private"? library_unit_declaration) | library_unit_body | ("private"? library_unit_renaming_declaration) ;
library_unit_declaration ::= subprogram_declaration | package_declaration | generic_declaration | generic_instantiation ;
library_unit_renaming_declaration ::= package_renaming_declaration | generic_renaming_declaration | subprogram_renaming_declaration ;
library_unit_body ::= subprogram_body | package_body ;
context_clause ::= context_item* ;
context_item ::= with_clause | use_clause ;
with_clause ::= limited_with_clause | nonlimited_with_clause ;
limited_with_clause ::= "limited" "private"? "with" library_unit_name ("," library_unit_name)* ";" ;
nonlimited_with_clause ::= "private"? "with" library_unit_name ("," library_unit_name)* ";" ;
subunit ::= "separate" "(" parent_unit_name ")" proper_body ;
declarative_part ::= declarative_item* ;
declarative_item ::= basic_declarative_item | body ;
body ::= proper_body | body_stub ;
proper_body ::= subprogram_body | package_body | task_body | protected_body ;
sequence_of_statements ::= statement statement* ;
statement ::= (label* simple_statement) | (label* compound_statement) ;
compound_statement ::= if_statement | loop_statement | extended_return_statement | accept_statement | case_statement | block_statement | select_statement ;
if_statement ::= "if" condition "then" sequence_of_statements ("elsif" condition "then" sequence_of_statements)* ("else" sequence_of_statements)? "end" "if" ";" ;
case_statement ::= "case" expression "is" case_statement_alternative case_statement_alternative* "end" "case" ";" ;
case_statement_alternative ::= "when" discrete_choice_list "=>" sequence_of_statements ;
loop_statement ::= (loop_statement_identifier ":")? iteration_scheme? "loop" sequence_of_statements "end" "loop" loop_identifier? ";" ;
block_statement ::= (block_statement_identifier ":")? ("declare" declarative_part)? "begin" handled_sequence_of_statements "end" block_identifier? ";" ;
subprogram_body ::= overriding_indicator? subprogram_specification "is" declarative_part "begin" handled_sequence_of_statements "end" designator? ";" ;
extended_return_statement ::= "return" defining_identifier ":" "aliased"? return_subtype_indication (":=" expression)? ("do" handled_sequence_of_statements "end" "return")? ";" ;
package_body ::= "package" "body" defining_program_unit_name "is" declarative_part ("begin" handled_sequence_of_statements)? "end" ((parent_unit_name ".")? identifier)? ";" ;
task_body ::= "task" "body" defining_identifier "is" declarative_part "begin" handled_sequence_of_statements "end" task_identifier? ";" ;
protected_body ::= "protected" "body" defining_identifier "is" protected_operation_item* "end" protected_identifier? ";" ;
protected_operation_item ::= subprogram_declaration | subprogram_body | entry_body | aspect_clause ;
accept_statement ::= "accept" entry_direct_name ("(" entry_index ")")? parameter_profile ("do" handled_sequence_of_statements "end" entry_identifier?)? ";" ;
entry_body ::= "entry" defining_identifier entry_body_formal_part entry_barrier "is" declarative_part "begin" handled_sequence_of_statements "end" entry_identifier? ";" ;
select_statement ::= selective_accept | timed_entry_call | conditional_entry_call | asynchronous_select ;
selective_accept ::= "select" guard? select_alternative ("or" guard? select_alternative)* ("else" sequence_of_statements)? "end" "select" ";" ;
select_alternative ::= accept_alternative | delay_alternative | terminate_alternative ;
accept_alternative ::= accept_statement sequence_of_statements? ;
delay_alternative ::= delay_statement sequence_of_statements? ;
timed_entry_call ::= "select" entry_call_alternative "or" delay_alternative "end" "select" ";" ;
entry_call_alternative ::= procedure_or_entry_call sequence_of_statements? ;
conditional_entry_call ::= "select" entry_call_alternative "else" sequence_of_statements "end" "select" ";" ;
asynchronous_select ::= "select" triggering_alternative "then" "abort" abortable_part "end" "select" ";" ;
triggering_alternative ::= triggering_statement sequence_of_statements? ;
abortable_part ::= sequence_of_statements ;
handled_sequence_of_statements ::= sequence_of_statements ("exception" exception_handler exception_handler*)? ;
exception_handler ::= "when" (choice_parameter_specification ":")? exception_choice ("|" exception_choice)* "=>" sequence_of_statements ;
simple_statement ::= null_statement | assignment_statement | goto_statement | simple_return_statement | requeue_statement | abort_statement | code_statement | exit_statement | procedure_call_statement | entry_call_statement | delay_statement | raise_statement ;
null_statement ::= "null" ";" ;
basic_declaration ::= type_declaration | object_declaration | subprogram_declaration | null_procedure_declaration | renaming_declaration | generic_declaration | subtype_declaration | number_declaration | abstract_subprogram_declaration | package_declaration | exception_declaration | generic_instantiation ;
basic_declarative_item ::= basic_declaration | aspect_clause | use_clause ;
package_declaration ::= package_specification ";" ;
package_specification ::= "package" defining_program_unit_name "is" basic_declarative_item* ("private" basic_declarative_item*)? "end" ((parent_unit_name ".")? identifier)? ;
generic_declaration ::= generic_subprogram_declaration | generic_package_declaration ;
generic_package_declaration ::= generic_formal_part package_specification ";" ;
type_declaration ::= full_type_declaration | incomplete_type_declaration | private_type_declaration | private_extension_declaration ;
full_type_declaration ::= ("type" defining_identifier known_discriminant_part? "is" type_definition ";") | task_type_declaration | protected_type_declaration ;
type_definition ::= enumeration_type_definition | real_type_definition | record_type_definition | derived_type_definition | integer_type_definition | array_type_definition | access_type_definition | interface_type_definition ;
derived_type_definition ::= "abstract"? "limited"? "new" parent_subtype_indication (("and" interface_list)? record_extension_part)? ;
record_extension_part ::= "with" record_definition ;
subtype_declaration ::= "subtype" defining_identifier "is" subtype_indication ";" ;
object_declaration ::= (defining_identifier_list ":" "aliased"? "constant"? subtype_indication (":=" expression)? ";") | (defining_identifier_list ":" "aliased"? "constant"? access_definition (":=" expression)? ";") | (defining_identifier_list ":" "aliased"? "constant"? array_type_definition (":=" expression)? ";") | single_task_declaration | single_protected_declaration ;
single_task_declaration ::= "task" defining_identifier ("is" ("new" interface_list "with")? task_definition)? ";" ;
number_declaration ::= defining_identifier_list ":" "constant" ":=" static_expression ";" ;
enumeration_type_definition ::= "(" enumeration_literal_specification ("," enumeration_literal_specification)* ")" ;
enumeration_literal_specification ::= defining_identifier | defining_character_literal ;
defining_character_literal ::= character_literal ;
integer_type_definition ::= signed_integer_type_definition | modular_type_definition ;
signed_integer_type_definition ::= "range" static_simple_expression ".." static_simple_expression ;
modular_type_definition ::= "mod" static_expression ;
real_type_definition ::= floating_point_definition | fixed_point_definition ;
floating_point_definition ::= "digits" static_expression real_range_specification? ;
fixed_point_definition ::= ordinary_fixed_point_definition | decimal_fixed_point_definition ;
ordinary_fixed_point_definition ::= "delta" static_expression real_range_specification ;
decimal_fixed_point_definition ::= "delta" static_expression "digits" static_expression real_range_specification? ;
real_range_specification ::= "range" static_simple_expression ".." static_simple_expression ;
record_type_definition ::= ("abstract"? "tagged")? "limited"? record_definition ;
record_definition ::= ("record" component_list "end" "record") | ("null" "record") ;
component_list ::= (component_item component_item*) | (component_item* variant_part) | ("null" ";") ;
variant_part ::= "case" discriminant_direct_name "is" variant+ "end" "case" ";" ;
variant ::= "when" discrete_choice_list "=>" component_list ;
component_item ::= component_declaration | aspect_clause ;
abstract_subprogram_declaration ::= overriding_indicator? subprogram_specification "is" "abstract" ";" ;
incomplete_type_declaration ::= "type" defining_identifier discriminant_part? ("is" "tagged")? ";" ;
label ::= "<<" label_statement_identifier ">>" ;
label_statement_identifier ::= statement_identifier ;
assignment_statement ::= variable_name ":=" expression ";" ;
iteration_scheme ::= ("while" condition) | ("for" loop_parameter_specification) ;
loop_parameter_specification ::= defining_identifier "in" "reverse"? discrete_subtype_definition ;
exit_statement ::= "exit" loop_name? ("when" condition)? ";" ;
loop_name ::= name ;
goto_statement ::= "goto" label_name ";" ;
label_name ::= name ;
designator ::= ((parent_unit_name ".")? identifier) | operator_symbol ;
simple_return_statement ::= "return" expression? ";" ;
return_subtype_indication ::= subtype_indication | access_definition ;
null_procedure_declaration ::= overriding_indicator? procedure_specification "is" "null" ";" ;
private_type_declaration ::= "type" defining_identifier discriminant_part? "is" ("abstract"? "tagged")? "limited"? "private" ";" ;
private_extension_declaration ::= "type" defining_identifier discriminant_part? "is" "abstract"? ("limited" | "synchronized")? "new" ancestor_subtype_indication ("and" interface_list)? "with" "private" ";" ;
ancestor_subtype_indication ::= subtype_indication ;
renaming_declaration ::= object_renaming_declaration | exception_renaming_declaration | package_renaming_declaration | subprogram_renaming_declaration | generic_renaming_declaration ;
object_renaming_declaration ::= (defining_identifier ":" null_exclusion? subtype_mark "renames" object_name ";") | (defining_identifier ":" access_definition "renames" object_name ";") ;
object_name ::= name ;
exception_renaming_declaration ::= defining_identifier ":" "exception" "renames" exception_name ";" ;
package_renaming_declaration ::= "package" defining_program_unit_name "renames" package_name ";" ;
subprogram_renaming_declaration ::= overriding_indicator? subprogram_specification "renames" callable_entity_name ";" ;
callable_entity_name ::= name ;
generic_renaming_declaration ::= ("generic" "package" defining_program_unit_name "renames" generic_package_name ";") | ("generic" "procedure" defining_program_unit_name "renames" generic_procedure_name ";") | ("generic" "function" defining_program_unit_name "renames" generic_function_name ";") ;
task_type_declaration ::= "task" "type" defining_identifier known_discriminant_part? ("is" ("new" interface_list "with")? task_definition)? ";" ;
task_definition ::= task_item* ("private" task_item*)? "end" task_identifier? ;
task_item ::= entry_declaration | aspect_clause ;
protected_type_declaration ::= "protected" "type" defining_identifier known_discriminant_part? "is" ("new" interface_list "with")? protected_definition ";" ;
single_protected_declaration ::= "protected" defining_identifier "is" ("new" interface_list "with")? protected_definition ";" ;
protected_definition ::= protected_operation_declaration* ("private" protected_element_declaration*)? "end" protected_identifier? ;
protected_element_declaration ::= protected_operation_declaration | component_declaration ;
component_declaration ::= defining_identifier_list ":" component_definition (":=" default_expression)? ";" ;
protected_operation_declaration ::= subprogram_declaration | entry_declaration | aspect_clause ;
subprogram_declaration ::= overriding_indicator? subprogram_specification ";" ;
entry_declaration ::= overriding_indicator? "entry" defining_identifier ("(" discrete_subtype_definition ")")? parameter_profile ";" ;
entry_index ::= expression ;
entry_body_formal_part ::= ("(" entry_index_specification ")")? parameter_profile ;
entry_index_specification ::= "for" defining_identifier "in" discrete_subtype_definition ;
entry_barrier ::= "when" condition ;
requeue_statement ::= "requeue" entry_name ("with" "abort")? ";" ;
guard ::= "when" condition "=>" ;
condition ::= boolean_expression ;
boolean_expression ::= expression ;
triggering_statement ::= procedure_or_entry_call | delay_statement ;
delay_statement ::= delay_until_statement | delay_relative_statement ;
delay_until_statement ::= "delay" "until" delay_expression ";" ;
delay_relative_statement ::= "delay" delay_expression ";" ;
procedure_or_entry_call ::= procedure_call_statement | entry_call_statement ;
procedure_call_statement ::= (procedure_name ";") | (procedure_prefix actual_parameter_part ";") ;
procedure_name ::= name ;
entry_call_statement ::= entry_name actual_parameter_part? ";" ;
abort_statement ::= "abort" task_name ("," task_name)* ";" ;
task_name ::= name ;
body_stub ::= subprogram_body_stub | package_body_stub | task_body_stub | protected_body_stub ;
subprogram_body_stub ::= overriding_indicator? subprogram_specification "is" "separate" ";" ;
package_body_stub ::= "package" "body" defining_identifier "is" "separate" ";" ;
task_body_stub ::= "task" "body" defining_identifier "is" "separate" ";" ;
protected_body_stub ::= "protected" "body" defining_identifier "is" "separate" ";" ;
exception_declaration ::= defining_identifier_list ":" "exception" ";" ;
choice_parameter_specification ::= defining_identifier ;
exception_choice ::= exception_name | "others" ;
raise_statement ::= ("raise" ";") | ("raise" exception_name ("with" string_expression)? ";") ;
string_expression ::= expression ;
generic_subprogram_declaration ::= generic_formal_part subprogram_specification ";" ;
generic_formal_part ::= "generic" (generic_formal_parameter_declaration | use_clause)* ;
generic_formal_parameter_declaration ::= formal_object_declaration | formal_type_declaration | formal_subprogram_declaration | formal_package_declaration ;
formal_object_declaration ::= defining_identifier_list ":" mode null_exclusion? subtype_mark (":=" default_expression)? ";" defining_identifier_list ":" mode access_definition (":=" default_expression)? ";" ;
use_clause ::= use_package_clause | use_type_clause ;
use_package_clause ::= "use" package_name ("," package_name)* ";" ;
use_type_clause ::= "use" "type" subtype_mark ("," subtype_mark)* ";" ;
generic_instantiation ::= ("package" defining_program_unit_name "is" "new" generic_package_name generic_actual_part? ";") | (overriding_indicator? "procedure" defining_program_unit_name "is" "new" generic_procedure_name generic_actual_part? ";") | (overriding_indicator? "function" defining_designator "is" "new" generic_function_name generic_actual_part? ";") ;
formal_type_declaration ::= "type" defining_identifier discriminant_part? "is" formal_type_definition ";" ;
formal_type_definition ::= formal_private_type_definition | formal_derived_type_definition | formal_discrete_type_definition | formal_signed_integer_type_definition | formal_modular_type_definition | formal_floating_point_definition | formal_ordinary_fixed_point_definition | formal_decimal_fixed_point_definition | formal_array_type_definition | formal_access_type_definition | formal_interface_type_definition ;
formal_private_type_definition ::= ("abstract"? "tagged")? "limited"? "private" ;
discriminant_part ::= unknown_discriminant_part | known_discriminant_part ;
unknown_discriminant_part ::= "(<>)" ;
known_discriminant_part ::= "(" discriminant_specification (";" discriminant_specification)* ")" ;
discriminant_specification ::= (defining_identifier_list ":" null_exclusion? subtype_mark (":=" default_expression)?) | (defining_identifier_list ":" access_definition (":=" default_expression)?) ;
formal_derived_type_definition ::= "abstract"? ("limited" | "synchronized")? "new" subtype_mark (("and" interface_list)? "with" "private")? ;
formal_array_type_definition ::= array_type_definition ;
array_type_definition ::= unconstrained_array_definition | constrained_array_definition ;
unconstrained_array_definition ::= "array" "(" index_subtype_definition ("," index_subtype_definition)* ")" "of" component_definition ;
index_subtype_definition ::= subtype_mark "range" "<>" ;
constrained_array_definition ::= "array" "(" discrete_subtype_definition ("," discrete_subtype_definition)* ")" "of" component_definition ;
discrete_subtype_definition ::= discrete_subtype_indication | range ;
component_definition ::= ("aliased"? subtype_indication) | ("aliased"? access_definition) ;
formal_access_type_definition ::= access_type_definition ;
access_type_definition ::= (null_exclusion? access_to_object_definition) | (null_exclusion? access_to_subprogram_definition) ;
access_to_object_definition ::= "access" general_access_modifier? subtype_indication ;
general_access_modifier ::= "all" | "constant" ;
access_to_subprogram_definition ::= ("access" "protected"? "procedure" parameter_profile) | ("access" "protected"? "function" parameter_and_result_profile) ;
formal_interface_type_definition ::= interface_type_definition ;
interface_type_definition ::= ("limited" | "task" | "protected" | "synchronized")? "interface" ("and" interface_list)? ;
interface_list ::= interface_subtype_mark ("and" interface_subtype_mark)* ;
interface_subtype_mark ::= subtype_mark ;
formal_subprogram_declaration ::= formal_concrete_subprogram_declaration | formal_abstract_subprogram_declaration ;
formal_concrete_subprogram_declaration ::= "with" subprogram_specification ("is" subprogram_default)? ";" ;
formal_abstract_subprogram_declaration ::= "with" subprogram_specification "is" "abstract" subprogram_default? ";" ;
subprogram_specification ::= procedure_specification | function_specification ;
function_specification ::= "function" defining_designator parameter_and_result_profile ;
procedure_specification ::= "procedure" defining_program_unit_name parameter_profile ;
access_definition ::= (null_exclusion? "access" "constant"? subtype_mark) | (null_exclusion? "access" "protected"? "procedure" parameter_profile) | (null_exclusion? "access" "protected"? "function" parameter_and_result_profile) ;
parameter_profile ::= formal_part? ;
parameter_and_result_profile ::= (formal_part? "return" null_exclusion? subtype_mark) | (formal_part? "return" access_definition) ;
formal_part ::= "(" parameter_specification (";" parameter_specification)* ")" ;
parameter_specification ::= (defining_identifier_list ":" mode null_exclusion? subtype_mark (":=" default_expression)?) | (defining_identifier_list ":" access_definition (":=" default_expression)?) ;
defining_identifier_list ::= defining_identifier ("," defining_identifier)* ;
default_expression ::= expression ;
defining_designator ::= defining_program_unit_name | defining_operator_symbol ;
defining_operator_symbol ::= operator_symbol ;
defining_program_unit_name ::= (parent_unit_name ".")? defining_identifier ;
parent_unit_name ::= name ;
subprogram_default ::= default_name | "<>" | "null" ;
default_name ::= name ;
formal_package_declaration ::= "with" "package" defining_identifier "is" "new" generic_package_name formal_package_actual_part ";" ;
formal_package_actual_part ::= ("(" ("others" "=>")? "<>)") | generic_actual_part? | ("(" formal_package_association ("," formal_package_association)* ("," "others" "=><>")? ")") ;
formal_package_association ::= generic_association | (generic_formal_parameter_selector_name "=><>") ;
defining_identifier ::= identifier ;
generic_actual_part ::= "(" generic_association ("," generic_association)* ")" ;
generic_association ::= (generic_formal_parameter_selector_name "=>")? explicit_generic_actual_parameter ;
explicit_generic_actual_parameter ::= expression | variable_name | subprogram_name | entry_name | subtype_mark | package_instance_name ;
subprogram_name ::= name ;
aspect_clause ::= attribute_definition_clause | enumeration_representation_clause | record_representation_clause | at_clause ;
attribute_definition_clause ::= ("for" local_name "'" attribute_designator "use" expression ";") | ("for" local_name "'" attribute_designator "use" name ";") ;
enumeration_representation_clause ::= "for" first_subtype_local_name "use" enumeration_aggregate ";" ;
enumeration_aggregate ::= array_aggregate ;
record_representation_clause ::= "for" first_subtype_local_name "use" "record" mod_clause? component_clause* "end" "record" ";" ;
component_clause ::= component_local_name "at" position "range" first_bit ".." last_bit ";" ;
position ::= static_expression ;
first_bit ::= static_simple_expression ;
last_bit ::= static_simple_expression ;
code_statement ::= qualified_expression ";" ;
restriction ::= restriction_identifier | (restriction_parameter_identifier "=>" restriction_parameter_argument) ;
restriction_parameter_argument ::= name | expression ;
at_clause ::= "for" direct_name "use" "at" expression ";" ;
mod_clause ::= "at" "mod" static_expression ";" ;
parent_subtype_indication ::= subtype_indication ;
static_simple_expression ::= simple_expression ;
discriminant_direct_name ::= direct_name ;
loop_statement_identifier ::= statement_identifier ;
loop_identifier ::= identifier ;
block_statement_identifier ::= statement_identifier ;
statement_identifier ::= direct_name ;
block_identifier ::= identifier ;
procedure_prefix ::= prefix ;
package_name ::= name ;
exception_name ::= name ;
generic_package_name ::= name ;
generic_procedure_name ::= name ;
generic_function_name ::= name ;
task_identifier ::= identifier ;
protected_identifier ::= identifier ;
entry_direct_name ::= direct_name ;
entry_identifier ::= identifier ;
entry_name ::= name ;
delay_expression ::= expression ;
generic_formal_parameter_selector_name ::= selector_name ;
package_instance_name ::= name ;
first_subtype_local_name ::= local_name ;
component_local_name ::= local_name ;
local_name ::= direct_name | (direct_name "'" attribute_designator) | library_unit_name ;
library_unit_name ::= name ;
subtype_indication ::= null_exclusion? subtype_mark constraint? ;
subtype_mark ::= subtype_name ;
constraint ::= scalar_constraint | composite_constraint ;
scalar_constraint ::= range_constraint | digits_constraint | delta_constraint ;
composite_constraint ::= index_constraint | discriminant_constraint ;
range_constraint ::= "range" range ;
range ::= range_attribute_reference | (simple_expression ".." simple_expression) ;
digits_constraint ::= "digits" static_expression range_constraint? ;
index_constraint ::= "(" discrete_range ("," discrete_range)* ")" ;
discrete_range ::= discrete_subtype_indication | range ;
discriminant_constraint ::= "(" discriminant_association ("," discriminant_association)* ")" ;
discriminant_association ::= (discriminant_selector_name ("|" discriminant_selector_name)* "=>")? expression ;
discrete_choice_list ::= discrete_choice ("|" discrete_choice)* ;
discrete_choice ::= expression | discrete_range | "others" ;
name ::= direct_name | indexed_component | selected_component | type_conversion | character_literal | explicit_dereference | slice | attribute_reference | function_call ;
prefix ::= name | implicit_dereference ;
explicit_dereference ::= name "." "all" ;
implicit_dereference ::= name ;
indexed_component ::= prefix "(" expression ("," expression)* ")" ;
slice ::= prefix "(" discrete_range ")" ;
selected_component ::= prefix "." selector_name ;
attribute_reference ::= prefix "'" attribute_designator ;
attribute_designator ::= (identifier ("(" static_expression ")")?) | "Access" | "Delta" | "Digits" ;
range_attribute_reference ::= prefix "'" range_attribute_designator ;
range_attribute_designator ::= "Range" ("(" static_expression ")")? ;
aggregate ::= record_aggregate | extension_aggregate | array_aggregate ;
record_aggregate ::= "(" record_component_association_list ")" ;
record_component_association_list ::= (record_component_association ("," record_component_association)*) | ("null" "record") ;
record_component_association ::= ((component_choice_list "=>")? expression) | (component_choice_list "=><>") ;
extension_aggregate ::= "(" ancestor_part "with" record_component_association_list ")" ;
ancestor_part ::= expression | subtype_mark ;
array_aggregate ::= positional_array_aggregate | named_array_aggregate ;
positional_array_aggregate ::= ("(" expression "," expression ("," expression)* ")") | ("(" expression ("," expression)* "," "others" "=>" expression ")") | ("(" expression ("," expression)* "," "others" "=><>)") ;
named_array_aggregate ::= "(" array_component_association ("," array_component_association)* ")" ;
array_component_association ::= (discrete_choice_list "=>" expression) | (discrete_choice_list "=><>") ;
expression ::= (relation ("and" relation)*) | (relation ("or" relation)*) | (relation ("xor" relation)*) | (relation ("and" "then" relation)*) | (relation ("or" "else" relation)*) ;
relation ::= (simple_expression (relational_operator simple_expression)?) | (simple_expression "not"? "in" range) | (simple_expression "not"? "in" subtype_mark) ;
simple_expression ::= unary_adding_operator? term (binary_adding_operator term)* ;
term ::= factor (multiplying_operator factor)* ;
factor ::= (primary ("**" primary)?) | ("abs" primary) | ("not" primary) ;
primary ::= numeric_literal | "null" | string_literal | aggregate | name | qualified_expression | allocator | ("(" expression ")") ;
type_conversion ::= (subtype_mark "(" expression ")") | (subtype_mark "(" name ")") ;
qualified_expression ::= (subtype_mark "'(" expression ")") | (subtype_mark "'" aggregate) ;
allocator ::= ("new" subtype_indication) | ("new" qualified_expression) ;
function_call ::= function_name | (function_prefix actual_parameter_part) ;
actual_parameter_part ::= "(" parameter_association ("," parameter_association)* ")" ;
parameter_association ::= (formal_parameter_selector_name "=>")? explicit_actual_parameter ;
explicit_actual_parameter ::= expression | variable_name ;
delta_constraint ::= "delta" static_expression range_constraint? ;
subtype_name ::= name ;
static_expression ::= expression ;
discrete_subtype_indication ::= subtype_indication ;
variable_name ::= name ;
function_name ::= name ;
function_prefix ::= prefix ;
numeric_literal ::= decimal_literal | based_literal ;
decimal_literal ::= numeral ("." numeral)? exponent? ;
based_literal ::= base "#" based_numeral ("." based_numeral)? "#" exponent? ;
base ::= numeral ;
exponent ::= ("E" "+"? numeral) | ("E" "-" numeral) ;
numeral ::= digit (underline? digit)* ;
based_numeral ::= extended_digit (underline? extended_digit)* ;
extended_digit ::= digit | "A" | "B" | "C" | "D" | "E" | "F" ;
direct_name ::= identifier | operator_symbol ;
component_choice_list ::= (component_selector_name ("|" component_selector_name)*) | "others" ;
component_selector_name ::= selector_name ;
discriminant_selector_name ::= selector_name ;
formal_parameter_selector_name ::= selector_name ;
selector_name ::= identifier | character_literal | operator_symbol ;
character_literal ::= "'" graphic_character "'" ;
operator_symbol ::= string_literal ;
string_literal ::= """ string_element* """ ;
string_element ::= """" | non_quotation_mark_graphic_character ;
non_quotation_mark_graphic_character ::= graphic_character ;
restriction_identifier ::= identifier ;
restriction_parameter_identifier ::= identifier ;
identifier ::= identifier_start (identifier_start | identifier_extend)* ;
identifier_start ::= letter_uppercase | letter_lowercase | letter_titlecase | letter_modifier | letter_other | number_letter ;
identifier_extend ::= mark_non_spacing | mark_spacing_combining | number_decimal | punctuation_connector | other_format ;
formal_discrete_type_definition ::= "(<>)" ;
mode ::= "in"? | ("in" "out") | "out" ;
multiplying_operator ::= "*" | "/" | "mod" | "rem" ;
digit ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
formal_modular_type_definition ::= "mod" "<>" ;
null_exclusion ::= "not" "null" ;
highest_precedence_operator ::= "**" | "abs" | "not" ;
formal_signed_integer_type_definition ::= "range" "<>" ;
binary_adding_operator ::= "+" | "-" | "&" ;
formal_floating_point_definition ::= "digits" "<>" ;
formal_decimal_fixed_point_definition ::= "delta" "<>" "digits" "<>" ;
terminate_alternative ::= "terminate" ";" ;
unary_adding_operator ::= "+" | "-" ;
overriding_indicator ::= "not"? "overriding" ;
logical_operator ::= "and" | "or" | "xor" ;
formal_ordinary_fixed_point_definition ::= "delta" "<>" ;
relational_operator ::= "=" | "/=" | "<" | "<=" | ">" | ">=" ;
